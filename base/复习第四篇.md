#### 1、类型及检测方式

> 7 种类型为基础类型(Undefined、Null、Boolean、Number、String、Symbol、BigInt)，最后 1 种（Object）为引用类型

- 原始数据类型：基础数据类型存储在栈内存中、被引用或者浅拷贝时，会创建一个完全相等的变量；占据空间下，大小固定，属于被频繁使用的数据，放入栈中存储
- 引用数据类型：引用数据类型存储在堆内存中、存储的是地址，多个引用指向同一个地址，占据空间大，大小不固定，引用数据类型在栈中存储指针，然后该指针指向堆中该实体的起始地址，当解释器需要引用值时，会首先在栈中检索其在栈中的地址，取得地址后从堆中获得实体

##### javascript 数据存储在内存中？

> 在 javascript 中，原始数据类型的赋值会完整的复制变量值，而引用类型的赋值是复制引用地址

原始数据类型的值是放在栈中保存，引用类型的值是存放在堆中，因此在栈空间中（执行的上下文），原始数据类型存储的是变量的值，而引用类型存储的是在其“堆空间”中的地址  
在编译过程中，js 中的闭包的变量也是存储在堆空间中  
js 引擎通过用栈来维护程序的执行期间的上下文，栈空间不大，太大容易影响到上下文切换效率，堆空间很大，但分配内存和回收内存都需要消耗较多的时间

##### 数据类型检测

> (1)typeof

- 对于原始数据类型来说，除了 null 都能显示正确的类型
- 对于引用数据类型，除了函数其他都显示 object

```js
console.log(typeof  1)  //number
console.log(typeof  '1') // string
console.log(typeof  undefined) // undefined
console.log(typeof  []) // object
console.log(typeof  true) // boolean
console.log(typeof  null) // object
console.log(typeof  funcion(){}) // funcion
console.log(typeof  {}) // object
```

> (2)instanceof 用于检测某个构造函数的 prototype 是否出现在目标对象的原型链上

- 可以判断对象的类型，通过内部机制判断对象的原型链中是不是可以找到类型的 prototype
- 可以判断复杂引用数据类型，但是不能正确判断基础数据类型,

```js
console.log(true instanceof Boolean); //false
console.log(2 instanceof Number); // false
// console.log(undefined instanceof Undefined); //报错
// console.log(null instanceof Null);  //报错

// const a = function(){}
// console.log(a.__proto__ === Function.prototype) //true
```

> (3) constructor 是原型上的属性，实例继承自原型

- 除了 null,undefined,有 constructor 属性的基础（包装）类型或者对象类型都能准确判断，但是创建一个对象，更改它的原型就不可靠了
- 只是在实例身上进行判断,不会遍历整个原型链

```js
/g/.constructor === RegExp; //true

function Fn() {}
console.log(Fn.constructor === Function);

Fn.prototype = new Array();

var f = new Fn();
console.log(f.constructor === Function);
```

> Object.prototype.toString.call()

- toString()是 Object 的原型方法，调用该方法返回对应类型的字符串标记"[object Type]"

```js
console.log(Object.prototype.toString.call(["1"]));

function isType(value, type) {
  return Object.prototype.toString.call(value) === `[object ${type}]`;
}

console.log(isType([], "Array"));
```

##### Object 的转换规则

- 如果部署了 Symbol.toPrimitive 方法，优先调用再返回
- 调用 valueOf(),如果转换为基础类型，则返回
- 调用 toString(),如果转换为基础类型，则返回
- 如果都没有返回基础类型，则报错

```js
var object1 = {
  value: 1,
  valueOf() {
    return 2;
  },
  toString() {
    return 3;
  },
  [Symbol.toPrimitive]() {
    return 4;
  },
};
console.log(object1 + 0);
```

##### null 和 undefined 的区别？

- undefined 代表的是未定义，已声明，null 主要用于赋值一些可能返回对象的变量，作为初始化
- null 其实不是对象，虽然通过 typeof 返回 object,但是是 JS 一个历史悠久的 bug,在 JS 最初的版本使用的 32 位系统，为了性能考虑使用了低位存储变量的类型信息,000 开头代表的就是对象，然而 null 表示为全零，就错误判断为 object

#### 2、This

> this 就是一个对象，this 是在函数调用时发生的绑定，它指向什么完全取决于函数在哪里被调用

```js
function fn(){
    console.log(this.a)
}
var a = 1

fn()

const obj ={
    a:2
    fn:fn
}
obj.fn()
const c =new fn()
```

- 对于调用 fn 的来说, this 一定指向 window
- 对于 obj.fn()来说，随调用了该函数, this 就指向随，所以 this 指向 obj
- 对于 new 的方式来说，this 就绑定在 new 创建的对象

##### this 绑定确定流程

- 先确定函数调用位置，然后确定使用哪条规则，根据规则确定 this 绑定

##### this 绑定规则

- 默认绑定：this 绑定到全局对象
- 隐式绑定：一般绑定到调用对象，如 obj.fn 来说，绑定到 obj
- 显示绑定：通过 call、apply 指向 this 绑定到哪里  
   硬绑定：使用 bind 函数
- new 绑定：使用 new 关键字，绑定到当前函数对象

- 默认绑定 < 隐式绑定 < 显式绑定 < new 绑定

#### 3、闭包

> 闭包其实就是一个可以访问其他函数内部变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部作用域

- 闭包产生的本质就是：当前环境中存在指向父级作用域的引用

```js
var fun3;
function fun1() {
  var a = 1;
  fun3 = function () {
    console.log(a);
  };
}
fun1();
fun3();
```

##### 闭包的表现形式

- 返回一个函数
- 在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包

#### 4、new 原理

> new 关键字执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象

```js
function Person(){
    this.name = 'Ale'
    return '357'
}
var p = new Person()
console.log(p) // {name:'Ale'}
---
function Person2(){
    this.name = 'Ale'
    return {name:357}
}
var p2 = new Person2()
console.log(p2) // {name:357}
```

##### new 被调用之后所做的事情

- 让实例可以访问到私有属性
- 让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
- 构造函数返回的最后结果是引用数据类型

#### 5、原型与原型链

![关联图](../source/112.png)

> **proto** 和 prototype 关系: **proto** 和 consturctor 是对象独有的，prototype 属性是函数独有的

- javascript 对象通过引用来传递，我们创建的每一个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一修改
- 原型(prototype): 一个简单的对象，用于实现对象的属性继承，可以理解为对象的爹。
- 构造函数：可以通过 new 来新建一个对象的函数
- 实例：通过构造函数和 new 创建出来的对象就是实例，实例可以通过**proto**指向原型，通过 consturctor 指向构造函数

##### 原型链

> 原型链是由原型对象组成，每个对象都有`__proto__`属性，指向了创建该对象的构造函数原型，**proto**将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限对象链

- 属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链上一层级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 Object.prototype,如果还没有找到就返回 undefined
- 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果修改原型的属性时，则可以使用 b.prototype.x = 2； 但是这种会造成所有继承于该对象的实例的属性发生改变
- 对象可以通过 **proto** 来寻找不属于该对象的属性，**proto** 将对象连接起来组成了原型链

#### 6、继承

- 在 javascript 中并不存在类，class 只是语法糖，本质上还是函数

```js
class Person {}

console.log(Person instanceof Function);
```

##### 构造函数继承

```js
function Parent(age) {
  this.name = "张三"; 
  this.age = age;
}
function Child(age) {
  Parent.call(this, age);
}
const children = new Child(18);
```


##### js原型继承

```js
function Parent(){
    this.name = "张三"; 
}
function Child() {
  this.age = 19;
}
Child.prototype = new Parent()
const children = new Child()
console.dir(children.name)
```

##### 组合模式

