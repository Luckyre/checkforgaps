#### 1、类型及检测方式

> 7 种类型为基础类型(Undefined、Null、Boolean、Number、String、Symbol、BigInt)，最后 1 种（Object）为引用类型
- 原始数据类型：基础数据类型存储在栈内存中、被引用或者浅拷贝时，会创建一个完全相等的变量；占据空间下，大小固定，属于被频繁使用的数据，放入栈中存储
- 引用数据类型：引用数据类型存储在堆内存中、存储的是地址，多个引用指向同一个地址，占据空间大，大小不固定，引用数据类型在栈中存储指针，然后该指针指向堆中该实体的起始地址，当解释器需要引用值时，会首先在栈中检索其在栈中的地址，取得地址后从堆中获得实体

##### javascript数据存储在内存中？
 
> 在javascript中，原始数据类型的赋值会完整的复制变量值，而引用类型的赋值是复制引用地址

原始数据类型的值是放在栈中保存，引用类型的值是存放在堆中，因此在栈空间中（执行的上下文），原始数据类型存储的是变量的值，而引用类型存储的是在其“堆空间”中的地址   
在编译过程中，js中的闭包的变量也是存储在堆空间中  
js引擎通过用栈来维护程序的执行期间的上下文，栈空间不大，太大容易影响到上下文切换效率，堆空间很大，但分配内存和回收内存都需要消耗较多的时间  


##### 数据类型检测

> (1)typeof 
- 对于原始数据类型来说，除了null 都能显示正确的类型
- 对于引用数据类型，除了函数其他都显示object

```js
console.log(typeof  1)  //number
console.log(typeof  '1') // string
console.log(typeof  undefined) // undefined
console.log(typeof  []) // object
console.log(typeof  true) // boolean
console.log(typeof  null) // object
console.log(typeof  funcion(){}) // funcion
console.log(typeof  {}) // object
```


> (2)instanceof 用于检测某个构造函数的prototype是否出现在目标对象的原型链上
- 可以判断对象的类型，通过内部机制判断对象的原型链中是不是可以找到类型的prototype
- 可以判断复杂引用数据类型，但是不能正确判断基础数据类型, 

```js
console.log(true  instanceof Boolean); //false
console.log(2 instanceof Number); // false
// console.log(undefined instanceof Undefined); //报错
// console.log(null instanceof Null);  //报错

// const a = function(){}
// console.log(a.__proto__ === Function.prototype) //true

```

>(3) constructor 是原型上的属性，实例继承自原型
- 除了null,undefined,有constructor属性的基础（包装）类型或者对象类型都能准确判断，但是创建一个对象，更改它的原型就不可靠了
- 只是在实例身上进行判断,不会遍历整个原型链
```js
/g/.constructor === RegExp //true


function Fn(){}
console.log(Fn.constructor === Function)  

Fn.prototype = new Array()

var f = new Fn()
console.log(f.constructor === Function)
```


> Object.prototype.toString.call()

- toString()是Object 的原型方法，调用该方法返回对应类型的字符串标记"[object Type]"

```js
console.log(Object.prototype.toString.call(['1']))

function isType(value,type){
        return Object.prototype.toString.call(value) === `[object ${type}]`
}

console.log(isType([],'Array'))
```

##### Object 的转换规则

- 如果部署了Symbol.toPrimitive方法，优先调用再返回
- 调用valueOf(),如果转换为基础类型，则返回
- 调用toString(),如果转换为基础类型，则返回
- 如果都没有返回基础类型，则报错

```js
var object1 = {
    value: 1,
    valueOf(){
        return 2
    },
    toString(){
        return 3
    },
    [Symbol.toPrimitive](){
        return 4
    }
}
console.log(object1 + 0)
```


##### null和 undefined的区别？

- undefined代表的是未定义，已声明，null主要用于赋值一些可能返回对象的变量，作为初始化
- null其实不是对象，虽然通过typeof返回object,但是是JS一个历史悠久的bug,在JS最初的版本使用的32位系统，为了性能考虑使用了低位存储变量的类型信息,000开头代表的就是对象，然而null表示为全零，就错误判断为object
