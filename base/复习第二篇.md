### javascript

#### 1、如何渲染几万条数据并不卡住界面

通过 requestAnimationFrame 使用 60HZ 的刷新频率来达到 1/60\*1000ms（16ms）来渲染 DOM

```js
//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    window.requestAnimationFrame(function(){
        let fragment = document.createDocumentFragment();
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)
            fragment.appendChild(li)
        }
        ul.appendChild(fragment)
        loop(curTotal - pageCount,curIndex + pageCount)
    })
}
loop(total,index);

```
#### 2、数组去重方法

方法一: 利用ES6 Set去重  
```js
cosnt arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
 function unique(arr){
    return Array.from(new Set(arr))
 }
```
方法二:双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
```js

function unique(arr){
    for (let I = 0; I < arr.length; I++) {
        for (let J = I+1; J < arr.length; J++) {
            if(arr[I] == arr[J]){
                arr.splice(J,1);
                j--; // 删除后自减 
            }
        }
    }
}
```

方法三：通过indexOf
```js
function unique(arr){
    let array = []
    for (let index = 0; index < arr.length; index++) {
        if(array.indexOf(arr[index]) === -1){
            array.push(arr[index])
        }
    }
    return array
}
```

#### 3、浏览器缓存

<img src="../source/image/http_cache.png" alt=""/>

- 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，返回200，不会请求到服务器
- 当强缓存没有命中时，客户端浏览器会发送请求到服务器，服务器通过另外一些request header验证决策这个资源是否命中缓存，称为HTTP再验证，如果命中，服务器将请求返回304，但是不返回资源，
而是告诉客户端直接从缓存中获取，客户端收到返回就从缓存中获取资源
- 强缓存与协商缓存的共同之处在于，如果命中缓存，服务器都不会返回资源，但是不同点在于，强缓存过期时间内不会发送本次请求到服务器获取资源。
- 当ctr + F5 强制刷新网页时，直接从服务器加载，跳过强缓存与协商缓存


##### 强缓存  
- Expires(该字段时HTTP1.0的规范，时一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间)  
- Canche-Control:max-age (该字段是http1.1的规范)，强缓存利用max-age值来判断缓存资源的最大生命周期，单位是秒  
Cache-Control有一些常设置的值   
private：仅浏览器可以缓存（默认值）； 
public：浏览器和代理服务器都可以缓存；  
max-age=xxx：过期时间单位秒；  
no-cache：不进行强缓存；  
no-store：不强缓存，也不协商缓存）  

##### 协商缓存
- 
> 浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存流程如下:
- Last-Modified (值为资源的最后更新时间，随着服务器的response返回)
- if-Modified-Since （通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- ETag：当前资源在服务器的唯一标识（生成规则由服务器决定）ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的，优先级高于Last-Modified；在分布式的Web系统中，当访问落在不同的物理机上时会返回不同的ETag，进而导致304失效，降级为200请求（HTTP/1.1），需要Cache-Contral过期
- If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）




#### 4、

