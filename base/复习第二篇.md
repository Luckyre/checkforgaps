### javascript

#### 1、如何渲染几万条数据并不卡住界面

通过 requestAnimationFrame 使用 60HZ 的刷新频率来达到 1/60\*1000ms（16ms）来渲染 DOM

```js
//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    window.requestAnimationFrame(function(){
        let fragment = document.createDocumentFragment();
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)
            fragment.appendChild(li)
        }
        ul.appendChild(fragment)
        loop(curTotal - pageCount,curIndex + pageCount)
    })
}
loop(total,index);

```
#### 2、数组去重方法

方法一: 利用ES6 Set去重  
```js
cosnt arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
 function unique(arr){
    return Array.from(new Set(arr))
 }
```
方法二:双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。
```js

function unique(arr){
    for (let I = 0; I < arr.length; I++) {
        for (let J = I+1; J < arr.length; J++) {
            if(arr[I] == arr[J]){
                arr.splice(J,1);
                j--; // 删除后自减 
            }
        }
    }
}
```

方法三：通过indexOf
```js
function unique(arr){
    let array = []
    for (let index = 0; index < arr.length; index++) {
        if(array.indexOf(arr[index]) === -1){
            array.push(arr[index])
        }
    }
    return array
}
```

#### 3、浏览器缓存

<img src="../source/image/http_cache.png" alt=""/>

##### 强缓存  
- Expires(该字段时HTTP1.0的规范，时一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间)  
- Canche-Control:max-age (该字段是http1.1的规范)，强缓存利用max-age值来判断缓存资源的最大生命周期，单位是秒  
Cache-Control有一些常设置的值   
private：仅浏览器可以缓存（默认值）； 
public：浏览器和代理服务器都可以缓存；  
max-age=xxx：过期时间单位秒；  
no-cache：不进行强缓存；  
no-store：不强缓存，也不协商缓存）  

##### 协商缓存
- 


> 浏览器缓存分为强缓存和协商缓存，当客户端请求某个资源时，获取缓存流程如下:
- Last-Modified (值为资源的最后更新时间，随着服务器的response返回)
- if-Modified-Since


